# 运算符

## 四则运算符(+, -, *, /, %)
1. 加号(+)
	加号具有**加法**、**强制转换数字**和**字符串拼接**作用   
	如果加号放在操作数前面,表示强制转换为数字类型
	```js
	var str = "aliwang";
	+str;		//=>NaN 
	var num = "100";
	+num;       // => 100
	```
	如果左右操作数中有一个为非数字（除了布尔类型，undefined,null），则会把左右操作数转换为字符串，进行字符串拼接
	```js
	var a = 10, b = {"name": "aliwang"}, c = [];
	a + b;		//=>"10[object Object]"			a转换为字符串"10",b转换为字符串"[object Object]"
	b + c;		//=>"[object Object]"			b转换为字符串"[object Object]",c转换为字符串""
	```
	如果左右操作数都是数字，则进行加法运算
	```js
	var a = 10, b = 5;
	a + b;		//=>15
	```
2. 减号(-)
	减号具有**减法**和**强制转换数字并符号取反**作用
	如果左右操作数中有一个为非数字,则会把左右操作数强制转换为数字，进行减法运算
	```js
	var arr = "100";			//定义一个空数组
	arr = -arr;					
	console.log(arr);			//=>-100			字符串转换为数字，并符号取反（正数变负数）
	console.log(typeof arr);	//=>"number"	
	
	var a = 10, b = "5";
	console.log(a - b);		 //=>5
	
	var c = [];	 //定义一个空数组
	console.log(a - c);		 //=> 10		//先把数组c转换为数字0,再进行减法运算
	```
3. 乘号(*)
	如果左右操作数中有一个为非数字,则会把左右操作数强制转换为数字，进行乘法运算
	```js
	var a = 10, b = 3 , c = [] , d = { "name": "aliwang" };
	console.log(a * b);		//=>30
	console.log(b * c);		//=>0	c转换为数字0,再进行乘法运算
	console.log(c * d);      //NaN   c转换为数字0,d转换为NaN,再进行乘法运算
	```
4. 除号(/)
	如果左右操作数中有一个为非数字,则会把左右操作数强制转换为数字，进行除法运算
	```javascript
	var a = 10, b = -5 , c = [] , d = { "name": "aliwang" };
	console.log(a / b);		//=>-2	
	console.log(a / c);		//=> Infinity	c转换为数字0,再进行除法运算,因为除数为0,所以最终结果是正无穷大
	console.log(b / c);		//=>-Infinity   c转换为数字0,再进行除法运算,因为除数为0,所以最终结果是负无穷大
	console.log(c / d);     //NaN   c转换为数字0,d转换为NaN,再进行除法运算
	```
5. 求余(%)
	如果左右操作数中有一个为非数字,则会把左右操作数强制转换为数字，进行求余运算
	```js
	var a = 10, b = 3, c = [];
	console.log(a % b);		//=>1	
	console.log(a % c);		//=> NaN     	c转换为数字0,任何数对0求余，结果都为NaN
	```

## 赋值运算(=, +=, -=, *=, /=, %=)
此类运算符其实就是**四则运算符+赋值运算符**   
<!-- <img width="500" src="../../../../static/images/es6/赋值运算符.png"/> -->
```js
let a = 1;
console.log('=', a);
a += 1;
console.log('+=', a);
a -= 1;
console.log('-=', a);
a *= 2;
console.log('*=', a);
a /= 2;
console.log('/=', a);
a %= 2;
console.log('%=', a);
```

## 前/后增量,前/后减量(++, --) 一元运算符
根据符号在操作数前还是后，来判断属于前增或后增。
```javascript
var i = 10;
var a = i++;		        //这里的++是在变量i后面，属于后增量,所以先进行赋值运算,a = 10, 然后i = 10 + 1;
console.log('a = ',a);		//=> 10
console.log('i = ',i);		//=> 11

a = ++i;			//这里的++是在变量i前面，属于前增量,所以先运算i = 11 + 1，然后进行赋值运算a = 12;
console.log(a);		//=> 12
console.log(i);		//=> 12
```

## 比较运算符(>, <, >=, <=, ==, !=, ===, !==)
比较运算符总会把根据比较结果，**返回一个布尔值**，所以常常用于if、white和for等语句。
1. 大于(>)
	如果 第一个 操作 数 大于 第二个 操作 数， 则“>” 运算符 的 计算 结果 为 true； 否则 为 false。
	```js
	1 > 2;			//=>false
	"u1" < "u2";	//=>true  第一个字符相等，第二个字符2大于1
	```
2. 小于(<)
	如果 第一个 操作 数 小于 第二个 操作 数， 则“<” 运算符 的 计算 结果 为 true； 否则 为 false。
	```js
	1 < 2;			//=> true
	1 < 0;			//=> false
	```
3. 大于 等于（>=）
	如果 第一个 操作 数 大于 或者 等于 第二个 操作 数， 则“>=” 运算符 的 计算 结果 为 true； 否则 为 false。
	```js
	1 >= 2;			//=> false
	2 >= 1;			//=> true
	```
4. 小于 等于（<=）
	如果 第一个 操作 数 小于 或者 等于 第二个 操作 数， 则“<=” 运算符 的 计算 结果 为 true； 否则 为 false。
	```js
	1 <= 2;			//=> true
	2 <= 1;			//=> false
	```
5. 等于(==)
	如果 第一个 操作 数 等于 第二个 操作 数， 则“==” 运算符 的 计算 结果 为 true； 否则 为 false。
	```js
	1 == 2;			//=> false
	2 == 2;			//=> false
	```
6. 不等于(!=)
	如果 第一个 操作 数 不等于 第二个 操作 数， 则“!=” 运算符 的 计算 结果 为 true； 否则 为 false。
	```js
	1 != 2;			//=> true
	2 != 2;			//=> false
	```
	
**注意:**
- 上面6个比较运算符，只要有一个操作数是数字，则会自动把另一个操作数转换为数字，再进行比较。
- 如果两个都是字符串，则进行字符串的比较。（字符串的比较的本质是通过字符串每一位字符的unicode编码大小来比较大小）    
- 如果至少有一个操作数是`NaN`,则结果总是返回`false`  
 ```js
	1 > NaN;		//=> false
	1 < NaN;		//=> false
	1 != NaN;		//=> false
	NaN == NaN;	    //=> false
```
   
7.全等于、不全等于(===、!==)   
	三个等于号，代表除了值的相等以外，还需要类型一致（所以全等于/不全等于并不会对左右操作数进行类型转换）
```js
1 === 1;          // => true
'1' === 1;        // => false
```

## 逻辑运算符(||、&&、!)
与或非
1. 逻辑或(||)
	只要有一个操作数为真，则返回`true`
	```javascript
	var a = true, b = false;
	a || b;		//=>true  其中一个操作数为真
	0 || '';    // ''
	const val = Boolean(0 || '');
	console.log(val);
	```
2. 逻辑与(&&)
	只有两个操作数都为真，才返回`true`
	```js
	var a = true,b = false;
	a && b;		    //=>false   其中一个操作数为假
	
	b = true;
	a && b	;		//=>true  	两个操作数都为真
	```
3. 逻辑非(!)
	**感叹号(!)**放在单独操作数前,它是一个一元运算符,它首先把操作数转换为布尔值,再取反.
	```js
	var bool = true;
	!bool;          //=>false
	!100 < 50		//=>true   先运算100<50,得到false，再逻辑非运算,得到true
	```
	之前讲变量转换时，说到**双感叹号(!!)**来做转换符，就是做了两次的逻辑非运算，得到一个等价的布尔值
	
- 练习
	1. 以下代码运行后输出什么
	```js
	var i = 8;
	console.log( i < 5 && i < 10);		
	console.log( i > 100 || i < 10);   	
	console.log(!(10 > 5));		
	```

## 三元运算符

三元运算符又称为三目运算符，指的是根据不同的条件，执行不同的操作/返回不同的值。

语法结构为：条件 ？ 操作1 ： 操作2。 如果条件为真，执行操作1，否则执行操作2。
```js
var a = 1;
a ? console.log('真执行我') : console.log('假执行我');
```

## 位运算符(&, |, ^, ~, <<, >>, >>>)

学位运算符操作的时候，先了解js下二进制与十进制的相互转换的办法

### js中关于二进制与十进制的相互转换

十进制转二进制
```js
var a = 40;
console.log(a.toString(2)); //转成二进制 
```

二进制转十进制
```js
var a = 101000;
console.log(parseInt(a, 2)); //转成二进制 
```

1. 位的与运算(&)
	```js
	0x1234 & 0x00FF;		//=>十六进制结果为0x0034   十进制结果为52  
	```
	先把两个16进制的数字转化为二进制，分别是0001 0010 0011 0100和0000 0000 1111 1111, <b>按位数进行两两判断，都为1，则最终结果的对应位数为1</b>，得到结果是0000 0000 0011 0100 (换算为10进制就是4 + 16 + 32 = 52)
2. 位的或运算(|)
	```js
	0x1234 | 0x00FF;		//=>十六进制结果为0x12FF   十进制结果为4863  
	```
	先把两个16进制的数字转化为二进制，分别是0001 0010 0011 0100和0000 0000 1111 1111, <b>按位数进行两两判断，其中一个为1，则最终结果的对应位数为1</b>，得到结果是0001 0010 1111 1111 (换算为10进制就是1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 512 + 4096 = 4863)
	
- 位的异或运算(^)
	```javascript
	0x1234^0x00FF;		//=>十六进制结果为0x12CB   十进制结果为4811  
	```
	先把两个16进制的数字转化为二进制，分别是0001 0010 0011 0100和0000 0000 1111 1111, <b>按位数进行两两判断，只有对应位数的值不一样，最终结果的对应位数才为1</b>，得到结果是0001 0010 1100 1011 (换算为10进制就是1 + 2+ 8 + 64 + 128 + 512 + 4096 = 4811)
	
- 位的非运算(~)
	```javascript
	~100 ;      // =>十进制结果-101
	~-100 ;     // =>十进制结果99
	```
	相当于把<b>整数取反后减1</b>,100取反为-100，再减1,则为-101

	相当于把<b>整数取反后减1</b>,-100取反为100，再减1,则为99
- 位的左移运算(<<)
	将 第一个 操 作数 的 所有 二进制 位 进行 左移 操作， 移动 的 位数 由 第二个 操作数 指定， 移动 的 位数 是 0 ~ 31 之间 的 一个 整数。 例如， 在 表达式 a << 1 中， a 的 第一位 变成 了 第二位， a 的 第二位 变成 了 它的 第三 位， 以此类推。 新的 第一位 用 0 来 补充， 舍弃 第 32 位。
	```javascript
	7 << 2;   //=>28  (7*2*2)
	```
	十进制7转换为二进制0000 0111,左移动两位,变成0001 1100(相当于十进制28)   
	**技巧：将一个值左移1位 相当于它乘以2， 左移两位相当于乘以4， 以此类推，利用位运算的性能高的特点，可以优化程序的运行速度**
- 位的右移运算(>>)
	将第一个操作数的所有位进行右移操作，移动的位数由第二个操作数指定，移动的位数是0 ~ 31之间的一个整数。 右边溢出的位将忽略。填补在左边的位由原操作数的符号决定，以便保持结果的符号与原操作数一致。如果第一个操作数是正数，移位后用0填补最高位；如果第一个操作数是负的，移位后就用1填补高位。
	```javascript
	8 >> 1;   //=>4  (8/2)
	```
	十进制8转换为二进制0000 1000,右移动一位,变成0000 0100(相当于十进制4)   
	**技巧：将一个值右移1位 相当于它除以2， 右移两位相当于除以4， 以此类推，利用位运算的性能高的特点，可以优化程序的运行速度**

## 运算符优先级

从上往下

- . [] new
- ()
- ++ --
- ! ~ +(单目) -(单目) typeof void delete
- % * /
- +(双目) -(双目)
- << >> >>>
- < <= > >=
- == != ===
- &
- ^
- |
- && 
- ? :
- = += -= *= /= %= <<= >>= >>>= &= ^= |=
- ,